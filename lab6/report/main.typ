#set page(
  paper: "a4",
  margin: (x: 2cm, y: 3cm),
)
#set text(
  font: "New Computer Modern",
  size: 10pt
)

ФИО: Яровой Вадим \
ГР: 5140904/40102 \
Работа №6 "Полная вычислительная модель логического программирования. Построение деревьев поиска" \

= Постановка задачи
== Правила
```
ibt(void, void).
ibt(t(_, L, R), t(_, U, V)) :- ibt(L, U), ibt(R, V).
```

= Основная часть
\/\/ рассмотрим следующий запрос
== ? ibt(t(a, L, R), T).

#table(
  columns: (auto, auto, auto, auto),
  inset: 10pt,
  [Резольвента], [Правило], [подстановка], [Комментарий],
  // line
  [{ibt(t(a, L, R), T)}],
  [ibt(t(\_, L1, R1), t(\_, U1, V1)) :- ibt(L1, U1), ibt(R1, V1).],
  [a = \_, L = L1, R = R1, T = t(\_, U1, V1) ],
  [Выбрано случайное правило. выполняется подостановка по правилу унификации. В результате мы получаем новую резольвенту.],
  // line
  [{*ibt(L1, U1)*, ibt(R1, V1)} (\*1)],
  [ibt(t(\_, L2, R2), t(\_, U2, V2)) :- ibt(L2, U2), ibt(R2, V2).],
  [L1 = t(\_, L2, R2), U1 = t(\_, U2, V2)],
  [Случайно выбрана подцель *ibt(L1, U1)*. Выбрано случайное правило. выполняется подостановка по правилу унификации. В результате мы получаем новую резольвенту из двух подцелей для проверки левого и правого поддеревьев. Таким образом получаем новое дерево поиска],
  // line
  [{*ibt(R1, V1)*, ibt(ibt(L2, U2), ibt(R2, V2))}],
  [ibt(void, void).],
  [R1 = void, V1 = void],
  [Случайно выбрана подцель *ibt(R1, V1)* Выбрано случайное правило. выполняется подостановка по правилу унификации. Получаем новую резольвенту],
  // line
  [{ibt(ibt(L2, U2), ibt(R2, V2))}],
  [...],
  [...],
  [...],
  // line
  [...],
  [...],
  [...],
  [...],
  [{}],
  [...],
  [...],
  [Получено бесконечное число решений],
  // line
  [{*ibt(R1, V1)*, ibt(L1, U1)} (\*2)],
  [ibt(t(\_, L3, R3), t(\_, U3, V3)) :- ibt(L3, U3), ibt(R3, V3).],
  [R1 = t(\_, L3, R3), V1 = t(\_, U3, V3)],
  [Случайно выбрана подцель *ibt(R1, V1)*. Выбрано случайное правило.  выполняется подостановка по правилу унификации. В результате мы получаем новую резольвенту из двух подцелей для проверки левого и правого поддеревьев. Таким образом получаем новое дерево поиска],
  // line
  [{*ibt(L1, U1)*, ibt(ibt(L3, U3), ibt(R3, V3))}],
  [ibt(void, void).],
  [L1 = void, U1 = void],
  [Случайно выбрана подцель *ibt(L1, U1)*. Выбрано случайное правило.  выполняется подостановка по правилу унификации. Получаем новую резольвенту],
  // line
  [{ibt(ibt(L3, U3), ibt(R3, V3))}],
  [...],
  [...],
  [...],
  // line
  [...],
  [...],
  [...],
  [...],
  // line
  [{}],
  [...],
  [...],
  [Получено бесконечное число решений],
)

